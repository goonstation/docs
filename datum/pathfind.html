<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><base href="../"><link rel="stylesheet" href="dmdoc.css"><title>/datum/pathfind - Goonstation 13</title></head><body><header><a href="index.html">Goonstation 13</a> - <a href="index.html#modules">Modules</a> - <a href="index.html#types">Types</a> — <a href="datum/pathfind.html#var">Var Details</a> - <a href="datum/pathfind.html#proc">Proc Details</a></header><main><h1>/<a href="datum.html">datum</a>/<a href="datum/pathfind.html">pathfind</a> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 165"></h1><p>The datum used to handle the JPS pathfinding, completely self-contained</p><table class="summary" cellspacing="0"><tr><td colspan="2"><h2>Vars</h2></td></tr><tr><th><a href="datum/pathfind.html#var/avoid">avoid</a></th><td>A specific turf we're avoiding, like if a mulebot is being blocked by someone t-posing in a doorway we're trying to get through</td></tr><tr><th><a href="datum/pathfind.html#var/caller_am">caller_am</a></th><td>The thing that we're actually trying to path for</td></tr><tr><th><a href="datum/pathfind.html#var/cardinal_only">cardinal_only</a></th><td>Whether we only want cardinal steps</td></tr><tr><th><a href="datum/pathfind.html#var/ends">ends</a></th><td>The turf we're trying to path to (note that this won't track a moving target)</td></tr><tr><th><a href="datum/pathfind.html#var/max_distance">max_distance</a></th><td>I don't know what this does vs , but they limit how far we can search before giving up on a path</td></tr><tr><th><a href="datum/pathfind.html#var/max_seen">max_seen</a></th><td>Max number of tiles seen, null skips the check</td></tr><tr><th><a href="datum/pathfind.html#var/mintargetdist">mintargetdist</a></th><td>How far away we have to get to the end target before we can call it quits</td></tr><tr><th><a href="datum/pathfind.html#var/n_target_goals">n_target_goals</a></th><td>The number of goals we need to find to succeed</td></tr><tr><th><a href="datum/pathfind.html#var/open">open</a></th><td>The open list/stack we pop nodes out from (TODO: make this a normal list and macro-ize the heap operations to reduce proc overhead)</td></tr><tr><th><a href="datum/pathfind.html#var/options">options</a></th><td>Raw associative list of options passed from get_path_to.</td></tr><tr><th><a href="datum/pathfind.html#var/paths">paths</a></th><td>The list we compile at the end if successful to pass back</td></tr><tr><th><a href="datum/pathfind.html#var/simulated_only">simulated_only</a></th><td>Space is big and empty, if this is TRUE then we ignore pathing through unsimulated tiles</td></tr><tr><th><a href="datum/pathfind.html#var/sources">sources</a></th><td>An assoc list that serves as the closed list &amp; tracks what turfs came from where. Key is the turf, and the value is what turf it came from</td></tr><tr><th><a href="datum/pathfind.html#var/start">start</a></th><td>The turf where we started at</td></tr><tr><th><a href="datum/pathfind.html#var/total_seen">total_seen</a></th><td>The total number of tiles seen so far</td></tr><tr><td colspan="2"><h2>Procs</h2></td></tr><tr><th><a href="datum/pathfind.html#proc/cardinal_scan_spec">cardinal_scan_spec</a></th><td>For performing cardinal scans from a given starting turf.</td></tr><tr><th><a href="datum/pathfind.html#proc/diag_scan_spec">diag_scan_spec</a></th><td>For performing diagonal scans from a given starting turf.</td></tr><tr><th><a href="datum/pathfind.html#proc/search">search</a></th><td>search() is the proc you call to kick off and handle the actual pathfinding, and kills the pathfind datum instance when it's done.</td></tr><tr><th><a href="datum/pathfind.html#proc/unwind_path">unwind_path</a></th><td>Called when we've hit the goal with the node that represents the last tile, then sets the path var to that path so it can be returned by <a href="datum/pathfind.html#proc/search" title="/datum/pathfind">datum/pathfind/proc/search</a></td></tr></table><h2 id="var">Var Details</h2><h3 id="var/avoid"><aside class="declaration">var </aside>avoid <aside>– /<a href="turf.html">turf</a></aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 194"></h3><p>A specific turf we're avoiding, like if a mulebot is being blocked by someone t-posing in a doorway we're trying to get through</p><h3 id="var/caller_am"><aside class="declaration">var </aside>caller_am <aside>– /<a href="atom.html">atom</a>/<a href="atom/movable.html">movable</a></aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 167"></h3><p>The thing that we're actually trying to path for</p><h3 id="var/cardinal_only"><aside class="declaration">var </aside>cardinal_only <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 196"></h3><p>Whether we only want cardinal steps</p><h3 id="var/ends"><aside class="declaration">var </aside>ends <aside>– /list/<a href="turf.html">turf</a></aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 173"></h3><p>The turf we're trying to path to (note that this won't track a moving target)</p><h3 id="var/max_distance"><aside class="declaration">var </aside>max_distance <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 188"></h3><p>I don't know what this does vs , but they limit how far we can search before giving up on a path</p><h3 id="var/max_seen"><aside class="declaration">var </aside>max_seen <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 190"></h3><p>Max number of tiles seen, null skips the check</p><h3 id="var/mintargetdist"><aside class="declaration">var </aside>mintargetdist <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 186"></h3><p>How far away we have to get to the end target before we can call it quits</p><h3 id="var/n_target_goals"><aside class="declaration">var </aside>n_target_goals <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 171"></h3><p>The number of goals we need to find to succeed</p><h3 id="var/open"><aside class="declaration">var </aside>open <aside>– /<a href="datum.html">datum</a>/<a href="datum/heap.html">heap</a></aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 175"></h3><p>The open list/stack we pop nodes out from (TODO: make this a normal list and macro-ize the heap operations to reduce proc overhead)</p><h3 id="var/options"><aside class="declaration">var </aside>options <aside>– /list</aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 198"></h3><p>Raw associative list of options passed from get_path_to.</p><h3 id="var/paths"><aside class="declaration">var </aside>paths <aside>– /list/list/<a href="turf.html">turf</a></aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 179"></h3><p>The list we compile at the end if successful to pass back</p><h3 id="var/simulated_only"><aside class="declaration">var </aside>simulated_only <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 192"></h3><p>Space is big and empty, if this is TRUE then we ignore pathing through unsimulated tiles</p><h3 id="var/sources"><aside class="declaration">var </aside>sources <aside>– /list</aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 177"></h3><p>An assoc list that serves as the closed list &amp; tracks what turfs came from where. Key is the turf, and the value is what turf it came from</p><h3 id="var/start"><aside class="declaration">var </aside>start <aside>– /<a href="turf.html">turf</a></aside> <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 169"></h3><p>The turf where we started at</p><h3 id="var/total_seen"><aside class="declaration">var </aside>total_seen <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 181"></h3><p>The total number of tiles seen so far</p><h2 id="proc">Proc Details</h2><h3 id="proc/cardinal_scan_spec"><aside class="declaration">proc </aside>cardinal_scan_spec<aside>(/<a href="turf.html">turf</a>/original_turf, heading, /<a href="datum.html">datum</a>/<a href="datum/jps_node.html">jps_node</a>/parent_node)  <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 320"></aside></h3><p>For performing cardinal scans from a given starting turf.</p>
<p>These scans are called from both the main search loop, as well as subscans for diagonal scans, and they treat finding interesting turfs slightly differently.
If we're doing a normal cardinal scan, we already have a parent node supplied, so we just create the new node and immediately insert it into the heap, ezpz.
If we're part of a subscan, we still need for the diagonal scan to generate a parent node, so we return a node datum with just the turf and let the diag scan
proc handle transferring the values and inserting them into the heap.</p>
<p>Arguments:</p>
<ul>
<li>original_turf: What turf did we start this scan at?</li>
<li>heading: What direction are we going in? Obviously, should be cardinal</li>
<li>parent_node: Only given for normal cardinal scans, if we don't have one, we're a diagonal subscan.</li>
</ul><h3 id="proc/diag_scan_spec"><aside class="declaration">proc </aside>diag_scan_spec<aside>(/<a href="turf.html">turf</a>/original_turf, heading, /<a href="datum.html">datum</a>/<a href="datum/jps_node.html">jps_node</a>/parent_node)  <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 395"></aside></h3><p>For performing diagonal scans from a given starting turf.</p>
<p>Unlike cardinal scans, these only are called from the main search loop, so we don't need to worry about returning anything,
though we do need to handle the return values of our cardinal subscans of course.</p>
<p>Arguments:</p>
<ul>
<li>original_turf: What turf did we start this scan at?</li>
<li>heading: What direction are we going in? Obviously, should be diagonal</li>
<li>parent_node: We should always have a parent node for diagonals</li>
</ul><h3 id="proc/search"><aside class="declaration">proc </aside>search<aside>()  <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 231"></aside></h3><p>search() is the proc you call to kick off and handle the actual pathfinding, and kills the pathfind datum instance when it's done.</p>
<p>If a valid path was found, it's returned as a list. If invalid or cross-z-level params are entered, or if there's no valid path found, we
return null, which <a href="global.html#proc/get_path_to" title="/global">/proc/get_path_to</a> translates to an empty list (notable for simple bots, who need empty lists)</p><h3 id="proc/unwind_path"><aside class="declaration">proc </aside>unwind_path<aside>(/<a href="datum.html">datum</a>/<a href="datum/jps_node.html">jps_node</a>/unwind_node)  <img src="git.png" width="16" height="16" title="_std/pathfinding.dm 286"></aside></h3><p>Called when we've hit the goal with the node that represents the last tile, then sets the path var to that path so it can be returned by <a href="datum/pathfind.html#proc/search" title="/datum/pathfind">datum/pathfind/proc/search</a></p></main><footer>goonstation.dme e18c4efa8a3ab2e13df0a169b767dbc7355e7294 — <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.10.0</a></footer></body></html>