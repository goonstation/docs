<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><base href="../"><link rel="stylesheet" href="dmdoc.css"><title>_std/types.dm - Goonstation 13</title></head><body><header><a href="index.html">Goonstation 13</a> - <a href="index.html#modules">Modules</a> - <a href="index.html#types">Types</a> — <a href="_std/types.html#define">Define Details</a></header><main><h1>_std/types.dm <img src="git.png" width="16" height="16" title="_std/types.dm"></h1><table class="summary" cellspacing="0"><tr><th><a href="_std/types.html#define/ENSURE_TYPE">ENSURE_TYPE</a></th><td>nulls a var if its value doesn't match the var's type</td></tr><tr><th>/proc/<a href="global.html#proc/concrete_typesof">concrete_typesof</a></th><td>[/proc/typesof()] but only for concrete (not abstract) types,
it caches the result so you don't need to worry about doing that manually
so subsequent calls on the same type will be very fast.</td></tr><tr><th>/proc/<a href="global.html#proc/filtered_concrete_typesof">filtered_concrete_typesof</a></th><td>The same thing but now you can filter the types using a proc. Also cached.
The filter proc takes a type and should return 1 if we want to include it and 0 otherwise.
That proc should also be pure (always return the same thing for the same arguments) because of the caching.
If you want to use non-pure proc do the filtering manually yourself and don't use this.
Note that the first call to filtered_concrete_typesof with a given type and filter will be (possibly a lot)
<em>slower</em> than doing it manually. The benefit of this proc only shows itself for future calls which are
very fast due to caching.</td></tr><tr><th>/proc/<a href="global.html#proc/get_singleton">get_singleton</a></th><td>Gets the instance of a singleton type (or a non-singleton type if you decide to use it on one).</td></tr><tr><th>/proc/<a href="global.html#proc/predecessor_path_in_list">predecessor_path_in_list</a></th><td>Find predecessor of a type</td></tr><tr><th>/proc/<a href="global.html#proc/maximal_subtype">maximal_subtype</a></th><td>Returns the maximal subtype (i.e. the most subby) in a list of given types</td></tr><tr><th>/var/<a href="global.html#var/by_type">by_type</a></th><td>contains lists of objects indexed by their type based on [START_TRACKING] / [STOP_TRACKING]</td></tr><tr><th><a href="_std/types.html#define/for_by_tcl">for_by_tcl</a></th><td>Loops over all instances of a type that's tracked via the [START_TRACKING] and [STOP_TRACKING] macros.
Example: for_by_tcl(gnome, /obj/item/gnomechompski) qdel(gnome)</td></tr><tr><th>/var/<a href="global.html#var/by_cat">by_cat</a></th><td>contains lists of objects indexed by a category string based on START_TRACKING_CAT / STOP_TRACKING_CAT</td></tr><tr><th>/typeinfo</th><td>type-level information type</td></tr><tr><th><a href="_std/types.html#define/TYPEINFO">TYPEINFO</a></th><td>Declares typeinfo for some type.</td></tr><tr><th>/proc/<a href="global.html#proc/get_type_typeinfo">get_type_typeinfo</a></th><td>Retrieves the typeinfo datum for a given type.</td></tr><tr><th>/proc/<a href="global.html#proc/type2parent">type2parent</a></th><td>Returns the parent type of a given type.
Assumes that parent_type was not overriden.</td></tr><tr><th>/proc/<a href="global.html#proc/find_first_by_type">find_first_by_type</a></th><td>Finds some instance of a type in the world. Returns null if none found.</td></tr><tr><th>/proc/<a href="global.html#proc/find_all_by_type">find_all_by_type</a></th><td>Finds all instance of a type in the world.
Returns a list of the instances if no procedure is given.
Otherwise, calls the procedure for each instance and returns an assoc list of the form list(instance = procedure(instance, arguments...), ...)
<code>procedure_src</code> is the src for the proc call. If it is null, a global proc is called.
If it is the string &quot;instance&quot; the output list will be instead list(instance = instance.procedure(arguments...), ...)</td></tr><tr><th>/proc/<a href="global.html#proc/istypes">istypes</a></th><td>istype but for checking a list of types</td></tr><tr><th>/proc/<a href="global.html#proc/get_random_subtype">get_random_subtype</a></th><td>Returns a random subtype when an atom has TYPEINFO with a random_subtypes list</td></tr><tr><th>/proc/<a href="global.html#proc/string_type_of_anything">string_type_of_anything</a></th><td>thing.type but it also returns &quot;num&quot; for numbers etc.</td></tr></table><h2 id="define">Define Details</h2><h3 id="define/ENSURE_TYPE"><aside class="declaration">#define </aside>ENSURE_TYPE<aside>(VAR)</aside> <img src="git.png" width="16" height="16" title="_std/types.dm 5"></h3><p>nulls a var if its value doesn't match the var's type</p><h3 id="define/TYPEINFO"><aside class="declaration">#define </aside>TYPEINFO<aside>(TYPE)</aside> <img src="git.png" width="16" height="16" title="_std/types.dm 263"></h3><p>Declares typeinfo for some type.</p>
<p>Example:</p>
<pre><code>TYPEINFO(/atom)
	var/monkeys_hate = FALSE

TYPEINFO(/obj/item/clothing/glasses/blindfold)
	monkeys_hate = TRUE
</code></pre>
<p>Treat this as if you were defining a type. You can add vars and procs, override vars and procs etc.
There might be minor issues if you define TYPEINFO of one type multiple times. Consider using <code>/typeinfo/THE_TYPE</code> for subsequent additions
to the object's typeinfo <strong>if you know it has already been declared once using TYPEINFO</strong>.</p><h3 id="define/for_by_tcl"><aside class="declaration">#define </aside>for_by_tcl<aside>(_iterator, _type)</aside> <img src="git.png" width="16" height="16" title="_std/types.dm 158"></h3><p>Loops over all instances of a type that's tracked via the [START_TRACKING] and [STOP_TRACKING] macros.
Example: for_by_tcl(gnome, /obj/item/gnomechompski) qdel(gnome)</p></main><footer>goonstation.dme e18c4efa8a3ab2e13df0a169b767dbc7355e7294 — <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.10.0</a></footer></body></html>