<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><base href="../"><link rel="stylesheet" href="dmdoc.css"><title>_std/math.dm - Goonstation 13</title></head><body><header><a href="index.html">Goonstation 13</a> - <a href="index.html#modules">Modules</a> - <a href="index.html#types">Types</a> — <a href="_std/math.html#define">Define Details</a></header><main><h1>_std/math.dm <img src="git.png" width="16" height="16" title="_std/math.dm"></h1><table class="summary" cellspacing="0"><tr><th><a href="_std/math.html#define/eulers">eulers</a></th><td>e</td></tr><tr><th><a href="_std/math.html#define/pi">pi</a></th><td>π</td></tr><tr><th><a href="_std/math.html#define/ceil2">ceil2</a></th><td>ceil, with second argument being the multiple to use for rounding</td></tr><tr><th><a href="_std/math.html#define/nround">nround</a></th><td>rounds down to the nearest integer, note that the built-in round() function alwys roundsd to the lower integer</td></tr><tr><th><a href="_std/math.html#define/posfract">posfract</a></th><td>decimal part of a number but always positive. Basically modulo 1 in a way</td></tr><tr><th><a href="_std/math.html#define/fractmodulo">fractmodulo</a></th><td>x % y but without rounding x first (i.e. fractmodulo(5.7, 2) = 1.7), also always positive</td></tr><tr><th><a href="_std/math.html#define/sign">sign</a></th><td>Returns the sign of the given number (1 or -1)</td></tr><tr><th><a href="_std/math.html#define/cot">cot</a></th><td>cotangent</td></tr><tr><th><a href="_std/math.html#define/percentmult">percentmult</a></th><td>Takes a probability 'x' (0-100) and returns the probability (0-100) of seeing at least 1 success were you to test 'x' 'mult' times.
Used for lag-compensating prob rolls.</td></tr><tr><th><a href="_std/math.html#define/angledifference">angledifference</a></th><td>difference in degrees from angle x to angle y</td></tr><tr><th><a href="_std/math.html#define/isnum_safe">isnum_safe</a></th><td>NaN isn't a number, damn it. Infinity is a problem too.</td></tr><tr><th>/proc/<a href="global.html#proc/text2num_safe">text2num_safe</a></th><td>Parses a number except for NaNs and infinities</td></tr><tr><th><a href="_std/math.html#define/randfloat">randfloat</a></th><td>rand() but for floats, returns a random floating point number between L and H</td></tr><tr><th><a href="_std/math.html#define/EXTRACT_BIT">EXTRACT_BIT</a></th><td>provides the bit at a position (starting from 0) in a binary number
example: <code>EXTRACT_BIT(9, 1)</code></td></tr><tr><th><a href="_std/math.html#define/TOGGLE_BIT">TOGGLE_BIT</a></th><td>toggles the bit at a position (starting from 0) in a binary number
example: <code>TOGGLE_BIT(9, 1)</code></td></tr><tr><th><a href="_std/math.html#define/CREATE_FULL_BINARY_NUM">CREATE_FULL_BINARY_NUM</a></th><td>creates a binary number that is length bits long. all bits in the number are turned on</td></tr><tr><th><a href="_std/math.html#define/CREATE_EMPTY_BINARY_NUM">CREATE_EMPTY_BINARY_NUM</a></th><td>creates a binary number that is length bits long. all bits in the number are turned off</td></tr><tr><th><a href="_std/math.html#define/lerp">lerp</a></th><td>Linearly interpolates a and b based on t</td></tr><tr><th>/proc/<a href="global.html#proc/fixed_random">fixed_random</a></th><td>pseudorandom number based on x, y in range 0 to 1</td></tr></table><h2 id="define">Define Details</h2><h3 id="define/CREATE_EMPTY_BINARY_NUM"><aside class="declaration">#define </aside>CREATE_EMPTY_BINARY_NUM<aside>(length)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 84"></h3><p>creates a binary number that is length bits long. all bits in the number are turned off</p><h3 id="define/CREATE_FULL_BINARY_NUM"><aside class="declaration">#define </aside>CREATE_FULL_BINARY_NUM<aside>(length)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 81"></h3><p>creates a binary number that is length bits long. all bits in the number are turned on</p><h3 id="define/EXTRACT_BIT"><aside class="declaration">#define </aside>EXTRACT_BIT<aside>(number, position)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 61"></h3><p>provides the bit at a position (starting from 0) in a binary number
example: <code>EXTRACT_BIT(9, 1)</code></p>
<p>9 in binary is <code>1001</code>
if i want to check the value of the 2nd bit in 9, i would use a value of 1 for position
this is because binary numbers start at 0 and bits are counted from right to left
then the &lt;&lt; operator shifts that bit a number of bits to the left
in this case, it shifts it 1 bit to the left, turning 1 into 10 (in binary)
so what the macro looks like now (in binary) is <code>1001 &amp; 0010</code>
the binary and operator (&amp;) multiplies the values of the bits together
so doing <code>1001 &amp; 0010</code> returns a value of <code>0000</code>
this tells us that the 2nd bit of <code>1001</code> is 0 (off)
if we did this with 11 (<code>1011</code>) instead, it would be <code>1011 &amp; 0010</code>, which would return <code>0010</code>, which tells us that the 2nd bit of <code>1001</code> is 1 (on)</p><h3 id="define/TOGGLE_BIT"><aside class="declaration">#define </aside>TOGGLE_BIT<aside>(number, position)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 78"></h3><p>toggles the bit at a position (starting from 0) in a binary number
example: <code>TOGGLE_BIT(9, 1)</code></p>
<p>9 in binary is <code>1001</code>
if i want to toggle the value of the 2nd bit in 9, i would use a value of 1 for position
this is because binary numbers start at 0 and bits are counted from right to left
then the &lt;&lt; operator shifts that bit a number of bits to the left
in this case, it shifts it 1 bit to the left, turning 1 into 10 (in binary)
so what the macro looks like now (in binary) is <code>1001 ^ 0010</code>
the binary xor operator (<code>^</code>) sets a bit to 0 if the values of the bits are the same and sets a bit to 1 if the values are different
so doing <code>1001 &amp; 0010</code> returns a value of <code>1011</code>
this just toggles the 2nd bit in the number from 0 to 1, or from 1 to 0
if we did this with 11 (<code>1011</code>) instead, it would be <code>1011 &amp; 0010</code>, which would return <code>1001</code></p><h3 id="define/angledifference"><aside class="declaration">#define </aside>angledifference<aside>(x, y)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 29"></h3><p>difference in degrees from angle x to angle y</p><h3 id="define/ceil2"><aside class="declaration">#define </aside>ceil2<aside>(x, y)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 7"></h3><p>ceil, with second argument being the multiple to use for rounding</p><h3 id="define/cot"><aside class="declaration">#define </aside>cot<aside>(x)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 22"></h3><p>cotangent</p><h3 id="define/eulers"><aside class="declaration">#define </aside>eulers <img src="git.png" width="16" height="16" title="_std/math.dm 2"></h3><p>e</p><h3 id="define/fractmodulo"><aside class="declaration">#define </aside>fractmodulo<aside>(x, y)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 16"></h3><p>x % y but without rounding x first (i.e. fractmodulo(5.7, 2) = 1.7), also always positive</p><h3 id="define/isnum_safe"><aside class="declaration">#define </aside>isnum_safe<aside>(x)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 32"></h3><p>NaN isn't a number, damn it. Infinity is a problem too.</p><h3 id="define/lerp"><aside class="declaration">#define </aside>lerp<aside>(a, b, t)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 87"></h3><p>Linearly interpolates a and b based on t</p><h3 id="define/nround"><aside class="declaration">#define </aside>nround<aside>(x)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 10"></h3><p>rounds down to the nearest integer, note that the built-in round() function alwys roundsd to the lower integer</p><h3 id="define/percentmult"><aside class="declaration">#define </aside>percentmult<aside>(x, mult)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 26"></h3><p>Takes a probability 'x' (0-100) and returns the probability (0-100) of seeing at least 1 success were you to test 'x' 'mult' times.
Used for lag-compensating prob rolls.</p><h3 id="define/pi"><aside class="declaration">#define </aside>pi <img src="git.png" width="16" height="16" title="_std/math.dm 4"></h3><p>π</p><h3 id="define/posfract"><aside class="declaration">#define </aside>posfract<aside>(x)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 13"></h3><p>decimal part of a number but always positive. Basically modulo 1 in a way</p><h3 id="define/randfloat"><aside class="declaration">#define </aside>randfloat<aside>(L, H)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 42"></h3><p>rand() but for floats, returns a random floating point number between L and H</p><h3 id="define/sign"><aside class="declaration">#define </aside>sign<aside>(x)</aside> <img src="git.png" width="16" height="16" title="_std/math.dm 19"></h3><p>Returns the sign of the given number (1 or -1)</p></main><footer>goonstation.dme e18c4efa8a3ab2e13df0a169b767dbc7355e7294 — <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.10.0</a></footer></body></html>